1)Implementation of the symbol table.

#include <stdio.h>
#include <string.h>

#define SIZE 10

struct Symbol {
    char name[20];
    char type[10];
} table[SIZE];

int count = 0;

void insert() {
    if (count >= SIZE) {
        printf("Table full!\n");
        return;
    }
    printf("Enter symbol name: ");
    scanf("%s", table[count].name);
    printf("Enter symbol type: ");
    scanf("%s", table[count].type);
    count++;
    printf("Symbol inserted!\n");
}

void search() {
    char name[20];
    printf("Enter name to search: ");
    scanf("%s", name);
    for (int i = 0; i < count; i++) {
        if (strcmp(table[i].name, name) == 0) {
            printf("Found: %s, Type: %s\n", table[i].name, table[i].type);
            return;
        }
    }
    printf("Symbol not found!\n");
}

void display() {
    printf("\nSymbol Table:\n");
    printf("Name\tType\n");
    printf("-----------------\n");
    for (int i = 0; i < count; i++)
        printf("%s\t%s\n", table[i].name, table[i].type);
}

int main() {
    int choice;
    while (1) {
        printf("\n1. Insert\n2. Search\n3. Display\n4. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1: insert(); break;
            case 2: search(); break;
            case 3: display(); break;
            case 4: return 0;
            default: printf("Invalid choice!\n");
        }
    }
}




2) Develop a lexical analyser to recognise a few patterns in (ex. Identifiers, constants, comments, 
operators, etc.) 


lexical.l

%{
#include <stdio.h>
int line_no = 1;
%}

%%
"//".*                { printf("Comment: %s\n", yytext); }
[a-zA-Z_][a-zA-Z0-9_]* { printf("Identifier: %s\n", yytext); }
[0-9]+(\.[0-9]+)?     { printf("Constant: %s\n", yytext); }
[+\-*/=<>]            { printf("Operator: %s\n", yytext); }
[\{\}\(\)\[\];,]      { printf("Delimiter: %s\n", yytext); }
\".*\"                { printf("String: %s\n", yytext); }
\n                    { line_no++; }
[ \t]+                ;   /* ignore whitespace */
.                     { printf("Unknown: %s\n", yytext); }
%%

int main() {
    yylex();
    printf("\nLines: %d\n", line_no);
    return 0;
}

int yywrap() { return 1; }


execution commands
		flex lexical.l
		gcc lex.yy.c
		./a.out


input 
	int a=10;


3)Implementation of a lexical analyser using the lex tool.

lexical .l


%{
#include <stdio.h>
#include <string.h>
int isKeyword(char *s) {
    char *k[] = {"int","float","char","if","else","for","while","return"};
    for (int i = 0; i < 8; i++)
        if (strcmp(s, k[i]) == 0) return 1;
    return 0;
}
%}
%%
"//".*                 { printf("Comment: %s\n", yytext); }
"/*"([^*]|\*+[^*/])*\*+"/" { printf("Comment: %s\n", yytext); }
[0-9]+(\.[0-9]+)?      { printf("Number: %s\n", yytext); }
[a-zA-Z_][a-zA-Z0-9_]* { isKeyword(yytext)?printf("Keyword: %s\n",yytext):printf("Id: %s\n",yytext); }
[+\-*/=<>!]            { printf("Operator: %s\n", yytext); }
[\(\)\{\}\[\];,]       { printf("Delimiter: %s\n", yytext); }
[ \t\n]+               ;
.                      { printf("Unknown: %s\n", yytext); }
%%
int main(){ yylex(); }
int yywrap(){ return 1; }


execution commands
		flex lexical.l
		gcc lex.yy.c
		./a.out


input 
	int a=10;

4)Generate a yacc specification for a few syntactic categories.  
a) Program to recognise a valid arithmetic expression that uses operators +,-, * and /.  
b) Program to recognise a valid variable which starts with a letter followed by any number 
of letters or digits. 
c) Implementation of a calculator using lex and yacc
			&
14)Write a YACC program to evaluate algebraic expression. 

calc.l
	


%{
#include "calc.tab.h"
#include <stdio.h>
#include <stdlib.h>
%}

%%
[0-9]+              { yylval = atoi(yytext); return NUMBER; }
[a-zA-Z][a-zA-Z0-9]* { return VARIABLE; }
[+\-*/()\n]         { return yytext[0]; }
[ \t]               ;
.                   { return yytext[0]; }
%%
int yywrap() { return 1; }


calc.y


%{
#include <stdio.h>
#include <stdlib.h>

int yylex();
int yyerror(char *s);
extern char *yytext;   
%}

%token NUMBER VARIABLE
%left '+' '-'
%left '*' '/'

%%
input:
    /* empty */
  | input expr '\n'   { printf("Result = %d\n", $2); }
  | input var '\n'    { printf("Valid variable: %s\n", yytext); }
  ;

expr:
      expr '+' expr   { $$ = $1 + $3; }
    | expr '-' expr   { $$ = $1 - $3; }
    | expr '*' expr   { $$ = $1 * $3; }
    | expr '/' expr   { $$ = $3 ? $1 / $3 : 0; }
    | '(' expr ')'    { $$ = $2; }
    | NUMBER          { $$ = $1; }
    ;

var:
    VARIABLE          { printf("Recognized variable: %s\n", yytext); }
    ;
%%
int main() {
    printf("Enter expressions or variable names (Ctrl+D to stop):\n");
    yyparse();
    return 0;
}

int yyerror(char *s) {
    printf("Invalid Expression\n");
    return 0;
}



execution           	flex calc.l
			bison -d calc.y
			gcc lex.yy.c calc.tab.c 
			./a.out


input 
	(2+3)*5



5. Convert the bnf rules into yacc form and write code to generate abstract syntax tree. 


calc.l


%{
#include "calc.tab.h"
#include <stdio.h>
%}

%%
[0-9]+      { yylval.s = strdup(yytext); return NUM; }
"("         { return '('; }
")"         { return ')'; }
[+*/-]      { return yytext[0]; }
[ \t\r]+    ;
\n          { return EOL; }
.           { return yytext[0]; }
%%

int yywrap() { return 1; }



calc.y

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct node {
    char *t;
    struct node *l, *r;
};

struct node *root;   // AST root

struct node* n(char *t, struct node *l, struct node *r) {
    struct node *p = malloc(sizeof(struct node));
    p->t = strdup(t);
    p->l = l;
    p->r = r;
    return p;
}

void print(struct node *t, int d) {
    if (!t) return;
    print(t->r, d + 1);
    for (int i = 0; i < d; i++) printf("   ");
    printf("%s\n", t->t);
    print(t->l, d + 1);
}

int yylex();
int yyerror(char *s) { printf("Error: %s\n", s); return 0; }
%}

%union {
    char *s;
    struct node *n;
}

%token <s> NUM
%token EOL
%type <n> expr term fac

%left '+' '-'
%left '*' '/'

%%

input:
      expr EOL      { root = $1; printf("\nAST:\n"); print(root, 0); }
    | EOL
    ;

expr:
      expr '+' term { $$ = n("+", $1, $3); }
    | expr '-' term { $$ = n("-", $1, $3); }
    | term          { $$ = $1; }
    ;

term:
      term '*' fac  { $$ = n("*", $1, $3); }
    | term '/' fac  { $$ = n("/", $1, $3); }
    | fac           { $$ = $1; }
    ;

fac:
      '(' expr ')'  { $$ = $2; }
    | NUM           { $$ = n($1, NULL, NULL); }
    ;

%%

int main() {
    printf("Enter expression:\n");
    yyparse();
    return 0;
}


execution
		flex calc.l
		bison -d calc.y
		gcc lex.yy.c calc.tab.c
		./a.out

input 
	(2+3)*5


6. Implement type checking 

#include <stdio.h>
#include <ctype.h>

int type(char *s) {
    int i = 0, dot = 0;

    while (s[i]) {
        if (s[i] == '.') dot++;
        else if (!isdigit(s[i])) return -1; 
        i++;
    }

    if (dot > 1) return -1;
    return (dot == 1) ? 1 : 0;      
}

int main() {
    char a[20], op, b[20];
    int t1, t2;

    printf("Enter expression (example: 3 + 4.5):\n");
    scanf("%s %c %s", a, &op, b);

    t1 = type(a);
    t2 = type(b);

    if (t1 == -1 || t2 == -1) {
        printf("Type Error: Invalid operands\n");
        return 0;
    }

    if (op != '+' && op != '-' && op != '*' && op != '/') {
        printf("Type Error: Invalid operator\n");
        return 0;
    }

    if (t1 == 0 && t2 == 0) printf("Result Type: INT\n");
    else printf("Result Type: FLOAT\n");

    return 0;
}


input 
	3+6
	4.5 + 5.0
	3 + 5.0



7)Implement any one storage allocation strategies (heap, stack, static) 


#include <stdio.h>
#include <string.h>

struct Frame {
    char name[10];
    int vars;
} stack[10];

int top = -1;

void push(char *f, int v) {
    strcpy(stack[++top].name, f);
    stack[top].vars = v;
    printf("Call: %s() -> %d vars allocated\n", f, v);
}

void pop() {
    printf("Return: %s() -> %d vars freed\n", stack[top].name, stack[top].vars);
    top--;
}

int main() {
    push("main", 2);
    push("funcA", 3);
    push("funcB", 1);
    pop();
    pop();
    pop();
    return 0;
}


8) Write a lex program to count the number of words and number of lines in a given file or program. 

lexical.l


%{
#include <stdio.h>
int lines = 0, words = 0;
%}

%%
\n          { lines++; }
[ \t]+      ;                     
[^ \t\n]+   { words++; }         
%%

int main() {
    yylex();
    printf("\nTotal Lines: %d\nTotal Words: %d\n", lines, words);
    return 0;
}

int yywrap() { return 1; }



input.txt

Hello world
This is Lex




execution 
			flex lexical.l
			gcc lex.yy.c 
			./a.out < input.txt


9)Write a ‘C’ program to implement lexical analyzer using c program. 
#include <stdio.h>
#include <ctype.h>
#include <string.h>

int isDelimiter(char ch) {
    return (ch == ' ' || ch == '+' || ch == '-' || ch == '*' || ch == '/' ||
            ch == ',' || ch == ';' || ch == '(' || ch == ')' ||
            ch == '{' || ch == '}' || ch == '=');
}

int isOperator(char ch) {
    return (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '=');
}

int isKeyword(char *str) {
    char keywords[][10] = {"if", "else", "while", "for", "int", "float", "char", "return"};
    for (int i = 0; i < 8; i++)
        if (strcmp(str, keywords[i]) == 0)
            return 1;
    return 0;
}

int isIdentifier(char *str) {
    if (!isalpha(str[0]) && str[0] != '_')
        return 0;
    for (int i = 1; str[i] != '\0'; i++)
        if (!isalnum(str[i]) && str[i] != '_')
            return 0;
    return 1;
}

int isNumber(char *str) {
    for (int i = 0; str[i] != '\0'; i++)
        if (!isdigit(str[i]))
            return 0;
    return 1;
}

int main() {
    char str[100], token[20];
    printf("Enter code: ");
    fgets(str, sizeof(str), stdin);

    int i = 0, j = 0;
    while (str[i] != '\0') {
        if (isDelimiter(str[i])) {
            if (j != 0) {
                token[j] = '\0';
                if (isKeyword(token)) printf("Keyword: %s\n", token);
                else if (isNumber(token)) printf("Number: %s\n", token);
                else if (isIdentifier(token)) printf("Identifier: %s\n", token);
                else printf("Unknown: %s\n", token);
                j = 0;
            }
            if (isOperator(str[i])) printf("Operator: %c\n", str[i]);
        } else token[j++] = str[i];
        i++;
    }
    return 0;
}



input 

int x = 25 + y;





10) write recursive descent parser for the grammar E->E+T E->T T->T*F T->F 
F->(E)/id. 


#include <stdio.h>
#include <string.h>

char s[50]; int i=0;

void E(); void T(); void F();

void E() { T(); while(s[i]=='+'){ i++; T(); } }
void T() { F(); while(s[i]=='*'){ i++; F(); } }
void F() {
    if(s[i]=='('){ i++; E(); if(s[i]==')') i++; else printf("Missing )\n"); }
    else if(s[i]=='i' && s[i+1]=='d'){ i+=2; }
    else printf("Error at %c\n",s[i]);
}

int main() {
    printf("Enter expr (use 'id' for identifiers): ");
    scanf("%s", s);
    E();
    if(s[i]=='\0') printf("Valid Expression\n");
    else printf("Invalid Expression\n");
}




input
	1)id+id*id


	2)a+b




11) Write a recursive descent parser for the grammar S->(L)    S->a 
L->L,S   L->S 



#include <stdio.h>
#include <string.h>

char s[50]; int i=0;

void S(), L();

void S() {
    if(s[i]=='('){ i++; L(); if(s[i]==')') i++; else printf("Missing )\n"); }
    else if(s[i]=='a') i++;
    else printf("Error at %c\n", s[i]);
}

void L() {
    S();
    if(s[i]==','){ i++; L(); }
}

int main() {
    printf("Enter string: ");
    scanf("%s", s);
    S();
    if(s[i]=='\0') printf("Valid String\n");
    else printf("Invalid String\n");
    return 0;
}




input
	1)(a,a)
	

	2) a,a)





12) Write a C program to calculate the first function for the grammar 
E->E+T  E->T   T->T*F  T->F     F->(E)/id 


#include <stdio.h>

void FIRST(char c);

int main() {
    char nonterminals[] = {'E', 'T', 'F'};
    printf("FIRST sets:\n");
    for (int i = 0; i < 3; i++) {
        printf("FIRST(%c) = { ", nonterminals[i]);
        FIRST(nonterminals[i]);
        printf("}\n");
    }
    return 0;
}

void FIRST(char c) {
    switch(c) {
        case 'E':
            printf("( , id"); 
            break;
        case 'T':
            printf("( , id"); 
            break;
        case 'F':
            printf("( , id"); 
            break;
    }
}


13) Write a YACC program to implement a top down parser for the given grammar.

grammer used 

E → E + T | T  
T → T * F | F  
F → (E) | id



lexer.l



%{
#include "parser.tab.h"
%}

%%
[0-9]+      { return ID; }
[a-zA-Z]+   { return ID; }
[ \t\n]     ;
.           { return yytext[0]; }
%%

int yywrap() { return 1; }




parser.y


%{
#include <stdio.h>
#include <stdlib.h>
int yylex();
int yyerror(char *s) { printf("Error: %s\n", s); return 0; }
%}

%token ID
%left '+' 
%left '*'

%%

E : E '+' T   { printf("E -> E + T\n"); }
  | T         { printf("E -> T\n"); }
  ;

T : T '*' F   { printf("T -> T * F\n"); }
  | F         { printf("T -> F\n"); }
  ;

F : '(' E ')' { printf("F -> (E)\n"); }
  | ID        { printf("F -> id\n"); }
  ;

%%

int main() {
    printf("Enter expression:\n");
    yyparse();
    printf("Parsing successful.\n");
    return 0;
}


execution

			yacc -d parser.y
			lex lexer.l
			gcc lex.yy.c y.tab.c 
			./a.out

input 
	id+id*id

